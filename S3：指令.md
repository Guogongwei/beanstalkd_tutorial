# Beanstalkd 服务端支持的指令。

[TOC]

前文提到，Beanstalkd 是由服务端和客户端组成的。其中服务端是通过接受来自客户端的指令来执行相关逻辑并管理队列。这里我们将介绍服务端支持的指令。

- **客户端包含生产者和消费者**
- **服务端接收指令后执行的是管理队列相关的逻辑**
- 客户端想要发送指令，首先要连接到服务器

## 生产者指令

### `put` 指令
* **put**：将任务插入到队列中。
```
put <pri> <delay> <ttr> <bytes>\r\n
<data>\r\n

<pri>: 整数  < 2**32 ，表明优先级。越小优先级的任务越先执行。
<delay>:整数，将任务放入ready队列前等待的秒数，此时它位于 delayed 状态
<ttr>: time to run 允许执行该任务的秒数，从任务变为 reserved 开始计时，如果任务执行超时，那么服务端将自动释放任务。最小 ttr为 1
<bytes>: 任务实体的长度，不包含 \r\n，必须小于 max-job-size (default: 2**16)
<data>: 任务实体
```

在客户端发送 put 指令之后，会等待服务端返回结果，其结果可能如下：

    - INSERTED <id>\r\n ： 成功，其中 id 是生成的任务 id
    - BURIED <id>\r\n ：服务器为了增加队列的优先级而内存不足时返回。
    - EXPECTED_CRLF\r\n ：body后面没有带上 \r\n
    - JOB_TOO_BIG\r\n ：任务实体长度超过了 max-job-size
    - DRAINING\r\n ：表示服务器已经进入了 drain mode ，服务器再也不能接受连接，客户端应该使用另一个服务器或者断开稍后重试

### `use` 指令
- **use**：声明后面跟随的 put 指令将要使用的 tube。不存在该 tube 时服务端会自动创建。

```
use <tube>\r\n

- <tube> 管道的名称，最多 200 字节。不存在时将自动创建。
```

服务端将会返回一下结果：

    - USING <tube>\r\n

## 消费者指令

如果一个进程想要消费队列中的任务，可以使用
* reserve
* delete
* release
* bury

### `reserve` 指令
```
reserve\r\n 或者 reserve-with-timeout <seconds>\r\n
```
执行后服务端将返回一个最新的任务，如果队列中没有任务，那么将会直到有任务才返回。
一旦一个任务被取出执行，那么该客户端需要在 ttr 的时间内完成该任务，如果任务执行超时，服务端会将任务移回 ready 队列。
执行时间和 ttr 可以通过 stats-job 指令获得。

timeout 如果设置成0，服务端会直接返回结果或者 TIMED_OUT，设置成一个正数则会在改数值时间内阻塞直到有新的可用任务。

#### `reserve` 服务端响应如下：

```
1、DEADLINE_SOON\r\n
```

在任务执行的 ttr 时间内，最后一秒被记为安全间隔，在此期间客户端不会等待执行其他的任务。
如果在刚好安全间隔上提交 reserve 指令，或者提交 reserve 之后到了执行到了安全间隔，则服务端将返回该结果。
此时客户端可以在服务端自动释放前选择删除或者释放当前执行的任务。

```
2、TIMED_OUT\r\n
```

在使用 reserve-with-timeout 并给予了超时时间下，在该时间内没有收到可执行的任务或者断开了连接（half-close ?）,服务端将返回该结果。

```
3、RESERVED <id> <bytes>\r\n
   <data>\r\n

- <id> 返回的 job id。
- <bytes> 任务实体的大小，不包括 '\r\n'
- <data> 任务实体，字节流。
```

### `delete` 指令

完全删除一个服务端的任务。通常客户端在任务成功运行后使用。

```
delete <id>\r\n
```

#### 参数

- <id> 指明要删除的 job。

#### 响应

客户端在发送指令后等待服务端单行响应：

- `DELETED\r\n` 指明成功的响应
- `NOT_FOUND\r\n`

### `release` 指令

该指令将一个 reserved 队列中的任务放回到 ready 队列（同时标明任务的状态为 ready），以供其他客户端使用。

```
release <id> <pri> <delay>\r\n
```

#### 参数

- `<id>`
- `<pri>` 重新设置优先级
- `<delay>` 任务在放入 ready 队列前等待的秒数，此时任务的状态为 delayed

#### 响应

- `RELEASED\r\n` 指明成功的响应
- `BURIED\r\n` 放入队列时内存空间不足
- `NOT_FOUND\r\n` 未找到该任务或者不在 reserve 中。

### `bury` 指令

将任务的状态置位 bury,此时该任务会被放入到一个先进先出的链表。使用 kick 指令可以将任务移出。
```
bury <id> <pri>\r\n
```

#### 参数

- `<id>`
- `<pri>` 新的优先级

#### 响应

- `BURIED\r\n` 成功
- `NOT_FOUND\r\n` 未找到该任务

### `touch` 指令

使执行者申请更多的执行时间，等于推迟任务的 ttr 时间至该命令提交时为起始重新计算。我们需要 ttr 的机制来将任务从未响应的执行者中拿回，所以执行者需要该命令来告诉服务端仍旧在执行任务（可能是在收到 `DEADLINE_SOON` 时进行 `touch`）。

```
touch <id>\r\n
```
#### 参数

- `<id>`

#### 响应

- `TOUCHED\r\n` 成功
- `NOT_FOUND\r\n` 未找到该任务

### `watch` 指令

将对应的管道纳入自己的监听列表。`reserve` 指令将会从监听列表中取出任务。对每个新的连接，默认初始化 `default` 管道。

```
watch <tube>\r\n
```

#### 参数

- `<tube>` 小于200字节，声明要 watch 的管道，如果不存在则服务端会自动创建

#### 响应

- `WATCHING <count>\r\n` 成功, count 指当前观察列表中的管道数。

### `ignore` 指令

将对应管道从观察列表中移除。

```
ignore <tube>\r\n
```

#### 参数

- `<tube>` 小于200字节，声明要 watch 的管道，如果不存在则服务端会自动创建

#### 响应

- `WATCHING <count>\r\n` 成功, count 指当前观察列表中的管道数。
- `NOT_IGNORED\r\n` 只剩下一个时禁止 ignore。

## 其他指令