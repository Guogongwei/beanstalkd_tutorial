# Beanstalkd 自定义协议介绍

[TOC]

Beanstalkd 是基于 TCP 的 ASCLL 编码协议， 客户端在连接服务端后发送数据和指令，并在接收响应之后关闭连接。对于每个连接，服务端按照接收到的命令序列依次处理并且依次响应。除特别声明外，所有整数型数字在协议中都被定义为非负的十进制。

**要学习 Beanstalkd，应该熟悉其实现的协议，知道它支持的字符编码、任务状态、对连接的处理、熟悉它支持的命令等**

## 命名约定

在本协议中，所有的命名都是 ASCLL 编码，即包括以下字符：

- 字母（A-Z 和 a-z）
- 数字（0-9）
- 连字符 ("-")
- 加号 ("+")
- 斜线 ("/")
- 分号 (";")
- 点 (".")
- 美元符 ("$")
- 下划线 ("_")
- 括号 ("(" and ")")

具体请查 ASCLL 字码表。

**需要注意的是**：命名不能以 - 起头和 空格结尾，命名至少要一个字符长度

## 数据类型

该协议中的数据类型有两种：单行字符串和非结构化的整块数据。

单行字串：用于描述客户端请求指令和服务端响应状态。
块数据：指任务实体和状态信息。

任务实体包含的是不透明的字节序列，服务端不会对实体做任何的检查和修改，只会原样的返回给客户端。任务实体的具体意义或行为都由客户端去定义和理解。

## connect

如果客户端不再被使用了，可以通过提交 quit 命令或者直接断开 TCP 连接的方式来解除和服务端的连接。

Beanstalkd 可以同时支持大量长连接，所以建议对一个客户端应该尽可能的保持连接来重复使用而不是每次重新建立TCP连接的方式。

## 错误状态码

如果客户端违反了协议（如发送了违反约定的请求体或者不存在的命令），或者服务端发生了错误，那么服务端将会发送下面的某个错误信息：

    - "OUT_OF_MEMORY\r\n" : 内存不足
    - "INTERNAL_ERROR\r\n" : 产生了一个不该发生的服务端bug，可以将错误报告发送给[http://groups.google.com/group/beanstalk-talk.
    ](http://groups.google.com/group/beanstalk-talk.
    )
    - "BAD_FORMAT\r\n": 客户端发送了非法的请求体
    - "UNKNOWN_COMMAND\r\n"：客户端发送了不存在的命令

在下面的具体指令描述中将不会列出这些 error，但是这些 error 状态实际包含在所有的指令中，客户端应该对于任何指令都应该做好处理这些 error 的准备

As a last resort, if the server has a serious error that prevents it from
continuing service to the current client, the server will close the
connection.

## 任务的生命周期

Beanstalkd 中的 job 是由客户端的 put 指令创建的，在其生命周期中，它总会处在以下四个状态中的某个：

- ready/reserved/delayed/buyied。

在 put 指令后，任务通常都出在 ready 状态，它将在 ready 的队列中等待直到接受到执行者的 reserve 指令。此时如果它是队列中的最后一个（轮到的那个），那么这个任务会被执行者置位为 reserved 再被执行。当任务执行结束后，执行者将发送 delete 命令删除该任务。下面是一个典型的任务周期图：
```
 put            reserve               delete
  -----> [READY] ---------> [RESERVED] --------> *poof*
```

当然任务的生命周期中还会有其他的状态：
```
 put with delay               release with delay
  ----------------> [DELAYED] <------------.
                        |                   |
                        | (time passes)     |
                        |                   |
   put                  v     reserve       |       delete
  -----------------> [READY] ---------> [RESERVED] --------> *poof*
                       ^  ^                |  |
                       |   \  release      |  |
                       |    `-------------'   |
                       |                      |
                       | kick                 |
                       |                      |
                       |       bury           |
                    [BURIED] <---------------'
                       |
                       |  delete
                        `--------> *poof*
```

## Tubes 管道

整个系统可以有多个管道（tube）。每个管道都有一个 ready 队列 和一个 delay 队列。每个任务的整个生命周期都是在该管道中进行的。消费者可以通过 watch 指令将某个管道纳入观察列表，也可以通过 ignore 指令将摸个管道移出观察列表，所以消费者执行的任务，都是来自于它的观察管道列表。

当一个客户端连接上服务端时，它将默认监听 default 管道。如果客户端 put 任务的时候没有指明（use）使用哪个管道，那么该任务也将被置于 default 管道中。

引用一个（watch、put？）不存在的管道时，服务端会自动创建该管道。如果管道没有任何 ready/delay/buried 任务，也没有任何客户端监听，那么它将被自动删除。

## 指令介绍

所有相关的指令请看下文。